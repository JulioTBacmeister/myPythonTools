import numpy as np
import xarray as xr
from datetime import datetime
import sys
import copy

#from itertools import product

#import esmlab

#import matplotlib.pyplot as plt


#def latlon_to_scrip(nx, ny, lon0=-180., grid_imask=None, file_out=None):
def latlon_to_scrip( grid_imask=None, file_out=None, lon0=-180., **kwargs ):
    """Generate a SCRIP grid file for a regular lat x lon grid.
    
    Parameters
    ----------
    
    nx : int
       Number of points in x (longitude).
    ny : int
       Number of points in y (latitude).
    lon0 : float, optional [default=-180]
       Longitude on lefthand grid boundary. No effect if
       if longitude vector is fed-in via kwargs !!!
    grid_imask : array-like, optional [default=None]       
       If the value is set to 0 for a grid point, then that point is
       considered masked out and won't be used in the weights 
       generated by the application. 
    file_out : string, optional [default=None]
       File to which to write the grid.

    Returns
    -------
    
    ds : xarray.Dataset
       The grid file dataset.       
    """
    
    if ('SkipAreaCheck' in kwargs):
        SkipAreaCheck_ = kwargs[ 'SkipAreaCheck' ]
    else:
        SkipAreaCheck_ = False
    
    if ('nx' in kwargs) and ('ny' in kwargs):
        # compute coordinates of regular grid
        nx = kwargs['nx']
        ny = kwargs['ny']
        dx = 360. / nx
        dy = 180. / ny
        lat = np.arange(-90. + dy / 2., 90., dy)
        lon = np.arange(lon0 + dx / 2., lon0 + 360., dx)
 
        # make 2D
        y_center = np.broadcast_to(lat[:, None], (ny, nx))
        x_center = np.broadcast_to(lon[None, :], (ny, nx))

        # compute corner points: must be counterclockwise
        y_corner = np.stack((y_center - dy / 2.,  # SW
                             y_center - dy / 2.,  # SE
                             y_center + dy / 2.,  # NE
                             y_center + dy / 2.), # NW
                            axis=2)

        x_corner = np.stack((x_center - dx / 2.,  # SW
                             x_center + dx / 2.,  # SE
                             x_center + dx / 2.,  # NE
                             x_center - dx / 2.), # NW
                            axis=2)

        
        
    elif (('longitudes' in kwargs) and ('latitudes' in kwargs)):
        lat = kwargs['latitudes']
        lon = kwargs['longitudes']

        nx  = np.size( lon )
        ny  = np.size( lat )

        lat_e = np.zeros( ny+1 )
        lat_c = np.zeros( ny )
        dlon = np.zeros( nx )
        dlat = np.zeros( ny )
        for j in np.arange(start=0,stop=ny-1):
            lat_e[j+1]=(lat[j]+lat[j+1])/2.
            #print( j,j+1, lat[j],lat[j+1],lat_e[j+1] )
        
        if (lat[0]< -85.):
            lat_e[0]=-90.
            lat_e[ny]=90.
        if (lat[0]> -85.):
            lat_e[0]=90.
            lat_e[ny]=-90.
   
        dlon[:] = np.abs( lon[1]-lon[0] )
        
        for j in np.arange(start=0,stop=ny):
            dlat[j] =np.abs(lat_e[j]-lat_e[j+1])
            lat_c[j]=(lat_e[j]+lat_e[j+1])/2.
            #print( j,j+1, lat[j],lat[j+1],lat_e[j+1] )
            if ( (j<5) or (j>ny-5) ):
                print( j, lat[j],dlat[j],lat_e[j],lat_e[j+1] )

        #print( lat_e )
        JNorth=np.arange(start=0,stop=ny)
        JSouth=np.arange(start=1,stop=ny+1)

        # make 2D
        y_edge   = np.broadcast_to(lat_e[:, None], (ny+1, nx))
        y_center = np.broadcast_to(lat[:, None], (ny, nx))
        x_center = np.broadcast_to(lon[None, :], (ny, nx))
        dy       = np.broadcast_to(dlat[:, None], (ny, nx))
        dx       = np.broadcast_to(dlon[None, :], (ny, nx))

        # compute corner points: must be counterclockwise
        y_corner = np.stack((y_edge[JSouth,:],  # SW
                             y_edge[JSouth,:],  # SE
                             y_edge[JNorth,:],  # NE
                             y_edge[JNorth,:] ), # NW
                            axis=2)
        x_corner = np.stack((x_center - dx / 2.,  # SW
                             x_center + dx / 2.,  # SE
                             x_center + dx / 2.,  # NE
                             x_center - dx / 2.), # NW
                            axis=2)

    else:
        try:
            lon in locals()
        except:
            print("lat-lon not provided and can't be calculated ")
            return -99999.

            
    print( "Shape Centers ", np.shape( y_center ))
    print( "Shape Corners ", np.shape( y_corner ))
    
    # compute area
    y0 = y_corner[:, :, 0] * np.pi / 180.   # south
    y1 = y_corner[:, :, 3] * np.pi / 180.   # north
    x0 = x_corner[:, :, 0] * np.pi / 180.   # west
    x1 = x_corner[:, :, 1] * np.pi / 180.   # east
    yC = y_center[:,:] * np.pi / 180.       # cell center
    grid_area = ( np.sin(y1) - np.sin(y0) ) * (x1 - x0)
    
    # sum of area should be equal to area of sphere
    if (SkipAreaCheck_ == True):
        print( " no test for area " )
    else:
        np.testing.assert_allclose(grid_area.sum(), 4.*np.pi)
    
    print( grid_area.sum(), 4.*np.pi, grid_area.sum() - 4.*np.pi,  )
    
    # construct mask
    if grid_imask is None:
        grid_imask = np.ones((ny, nx), dtype=np.int32)
    
    # generate output dataset
    dso = xr.Dataset()    
    dso['grid_dims'] = xr.DataArray(np.array([nx, ny], dtype=np.int32), 
                                    dims=('grid_rank',)) 
    dso.grid_dims.encoding = {'dtype': np.int32}

    dso['grid_center_lat'] = xr.DataArray(y_center.reshape((-1,)), 
                                          dims=('grid_size'),
                                          attrs={'units': 'degrees'})

    dso['grid_center_lon'] = xr.DataArray(x_center.reshape((-1,)), 
                                          dims=('grid_size'),
                                          attrs={'units': 'degrees'})
    
    dso['grid_corner_lat'] = xr.DataArray(y_corner.reshape((-1, 4)), 
                                          dims=('grid_size', 'grid_corners'), 
                                          attrs={'units': 'degrees'})
    dso['grid_corner_lon'] = xr.DataArray(x_corner.reshape((-1, 4)), 
                                      dims=('grid_size', 'grid_corners'), 
                                      attrs={'units': 'degrees'})    

    dso['grid_imask'] = xr.DataArray(grid_imask.reshape((-1,)), 
                                     dims=('grid_size'),
                                     attrs={'units': 'unitless'})
    dso.grid_imask.encoding = {'dtype': np.int32}
    
    dso['grid_area'] = xr.DataArray(grid_area.reshape((-1,)), 
                                     dims=('grid_size'),
                                     attrs={'units': 'radians^2',
                                            'long_name': 'area weights'})
    
    # force no '_FillValue' if not specified
    for v in dso.variables:
        if '_FillValue' not in dso[v].encoding:
            dso[v].encoding['_FillValue'] = None

    dso.attrs = {'title': f'{dy} x {dx} (lat x lon) grid',
                 'created_by': 'latlon_to_scrip',
                 'date_created': f'{datetime.now()}',
                 'conventions': 'SCRIP',
                }
            
    # write output file
    if file_out is not None:
        print(f'writing {file_out}')
        dso.to_netcdf(file_out)
        
    return dso
    
